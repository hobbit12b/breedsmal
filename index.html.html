<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Breed of Smal ‚Äî Kleuterspel</title>
  <style>
    :root {
      --bg1: #f9fbff;
      --bg2: #eef6ff;
      --ink: #1b2430;
      --brand: #6c7cff;
      --card: #ffffff;
      --shadow: 0 10px 30px rgba(0,0,0,.08);
    }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: ui-rounded, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      color: var(--ink);
      background: radial-gradient(1200px 800px at 10% 0%, var(--bg2), var(--bg1));
      display: grid;
      place-items: center;
    }
    .app { width: min(1000px, 94vw); height: min(720px, 88vh); background: var(--card); border-radius: 24px; box-shadow: var(--shadow); display: grid; grid-template-rows: 70px auto 80px; overflow: clip; position: relative; }

    header { display: grid; grid-template-columns: 1fr auto auto; align-items: center; gap: 12px; padding: 0 16px; background: linear-gradient(90deg, #dfe6ff, #f1f6ff); border-bottom: 1px solid #e6ecff; }
    .brand { display: flex; align-items: center; gap: 12px; font-weight: 800; }
    .brand .mascot { font-size: 28px; }
    .pill { background: #fff; border: 1px solid #e6ecff; border-radius: 999px; padding: 8px 14px; cursor: pointer; user-select: none; box-shadow: 0 2px 10px rgba(0,0,0,.04); transition: transform .1s ease; font-weight: 600; }
    .pill:active { transform: scale(.98); }

    .board { display: grid; grid-template-columns: 1fr 240px; gap: 18px; padding: 16px; height: 100%; background: radial-gradient(800px 600px at 70% 40%, #f5f9ff, #fff); position: relative; }
    .playzone { position: relative; z-index: 2; }
    .hud { display: grid; grid-template-rows: 1fr; }
    .card { background: #fff; border: 1px solid #eef3ff; border-radius: 16px; padding: 12px; box-shadow: var(--shadow); display: grid; place-items: center; }

    .drop-circle { width: 200px; height: 200px; border-radius: 50%; background: conic-gradient(from 0deg, #e9f0ff, #f7fbff, #e9f0ff); border: 6px solid #d8e4ff; display: grid; place-items: center; box-shadow: inset 0 8px 30px rgba(0,0,0,.05); position: relative; overflow: visible; z-index: 1; }
    .drop-circle.glow { box-shadow: 0 0 0 10px rgba(108,124,255,.12), inset 0 8px 30px rgba(0,0,0,.05); }
    .drop-circle.shake { animation: shake .4s ease; }
    @keyframes shake { 0% { transform: translateX(0); } 25% { transform: translateX(-6px); } 50% { transform: translateX(6px); } 75% { transform: translateX(-4px); } 100% { transform: translateX(0); } }

    .shape { position: absolute; border-radius: 16px; box-shadow: 0 10px 20px rgba(0,0,0,.08); display: grid; place-items: center; color: rgba(255,255,255,.9); user-select: none; touch-action: none; border: 4px solid rgba(255,255,255,.7); font-weight: 800; letter-spacing: .3px; z-index: 3; transform: none !important; }
    .shape[data-kind="A"] { background: linear-gradient(180deg, #8ec5ff, #6c7cff); }
    .shape[data-kind="B"] { background: linear-gradient(180deg, #ffcd8e, #ffb86c); }
    .shape.dragging { outline: 4px solid #c6d3ff; z-index: 5; transform: none !important; }
    .shape.good { animation: none; transform: none !important; box-shadow: 0 0 0 8px rgba(108,124,255,.18), 0 10px 20px rgba(0,0,0,.08); }

    /* cartoonogen */
    .shape .eyes, .shape .eyes-closed { position: absolute; inset: 0; display: flex; justify-content: space-evenly; align-items: center; pointer-events: none; transition: opacity .15s ease; }
    .shape .eyes-closed { opacity: 0; }
    .shape.dragging .eyes { opacity: 0; }
    .shape.dragging .eyes-closed { opacity: 1; }
    .eye { width: 34%; max-width: 120px; aspect-ratio: 3 / 4; background: #fff; border-radius: 50%; border: 3px solid rgba(255,255,255,.95); box-shadow: inset 0 -10px 16px rgba(0,0,0,.08); position: relative; overflow: hidden; }
    .eye .pupil { position: absolute; width: 34%; aspect-ratio: 1; background: #111; border-radius: 50%; left: 50%; top: 58%; transform: translate(-50%, -50%); transition: left .36s cubic-bezier(.25,.8,.25,1), top .36s cubic-bezier(.25,.8,.25,1); }
    .eye .lid-top, .eye .lid-bottom { position: absolute; left: 0; right: 0; height: 0; background: #fff; border-radius: 50%/40%; pointer-events: none; }
    .eye .lid-top { top: 0; border-bottom: 3px solid var(--rim, rgba(255,255,255,.85)); transform-origin: top; }
    .eye .lid-bottom { bottom: 0; border-top: 3px solid var(--rim, rgba(255,255,255,.85)); transform-origin: bottom; }
    .shape.dragging .eye .lid-top, .shape.dragging .eye .lid-bottom { height: 60%; transition: height .12s ease; }
    .eye.blink .lid-top { animation: blinkTop .14s ease-in-out 1; }
    .eye.blink .lid-bottom { animation: blinkBottom .14s ease-in-out 1; }
    @keyframes blinkTop { 0% { height: 0; } 50% { height: 65%; } 100% { height: 0; } }
    @keyframes blinkBottom { 0% { height: 0; } 50% { height: 65%; } 100% { height: 0; } }

    .footer { display: grid; grid-template-columns: auto 1fr auto; align-items: center; padding: 12px 16px 18px; background: #fafcff; border-top: 1px solid #eef3ff; min-height: 64px; }
    .streak { display: flex; align-items: center; gap: 8px; padding-left: 4px; }
    .streak .sDot { width: 12px; height: 12px; border-radius: 50%; background: #dde6ff; box-shadow: inset 0 0 0 2px #cdd8ff; transform: scale(0.9); transition: transform .18s ease; }
    .streak .sDot.on { background: var(--brand); box-shadow: 0 0 0 4px rgba(108,124,255,.15); transform: scale(1.05); }
    .tip { font-weight: 800; color: #5c6fb3; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; text-align: center; width: 100%; min-height: 28px; }

    .celebration { position: absolute; inset: 0; pointer-events: none; }
    .confetti { position: absolute; width: 10px; height: 14px; border-radius: 2px; opacity: .9; animation: fall 2.2s linear forwards; }
    @keyframes fall { 0% { transform: translateY(-30px) rotate(0deg); } 100% { transform: translateY(760px) rotate(520deg); } }

    .big-start { position: absolute; inset: 0; display: grid; place-items: center; background: rgba(255,255,255,.88); backdrop-filter: blur(2px); z-index: 10; }
    .big-start .panel { background: #fff; border: 2px solid #e8efff; border-radius: 24px; padding: 28px; text-align: center; box-shadow: var(--shadow); max-width: 520px; }
    .big { font-size: 22px; font-weight: 900; color: #3c4a73; margin-bottom: 14px; }
    .small { color: #6b7abb; }
    .btn-primary { background: var(--brand); color: white; }
    .hidden { display: none !important; }
  </style>
</head>
<body>
  <div class="app" id="app">
    <header>
      <div class="brand"><span class="mascot">üü¶</span> <span>Breed of Smal</span></div>
      <button class="pill" id="btnRepeat" title="Herhaal de opdracht">üîÅ Herhaal</button>
      <button class="pill" id="btnMute" title="Geluid aan of uit">üîä Geluid</button>
    </header>

    <div class="board">
      <div class="playzone" id="playzone"></div>
      <div class="hud">
        <div class="card"><div class="drop-circle" id="dropCircle" aria-label="Antwoord cirkel"></div></div>
      </div>
    </div>

    <div class="footer">
      <div class="streak" id="streak"></div>
      <div class="tip" id="tip">&nbsp;</div>
      <div class="spacer"></div>
    </div>

    <div class="celebration" id="celebration"></div>
    <div class="big-start" id="gate">
      <div class="panel">
        <div class="big">Klaar voor het spel</div>
        <div class="small" style="margin-bottom:16px;">Tik op Start om te beginnen</div>
        <button class="pill btn-primary" id="btnStart" style="font-size:18px; padding:12px 20px;">Start</button>
      </div>
    </div>
  </div>

  <script>
    // Elementen
    const app = document.getElementById('app');
    const playzone = document.getElementById('playzone');
    const dropCircle = document.getElementById('dropCircle');
    const tipEl = document.getElementById('tip');
    const celebration = document.getElementById('celebration');
    const btnStart = document.getElementById('btnStart');
    const gate = document.getElementById('gate');
    const btnRepeat = document.getElementById('btnRepeat');
    const btnMute = document.getElementById('btnMute');
    const streakEl = document.getElementById('streak');

    // Staat
    let audioOn = true; let compared = false; let voiceChoice = null; let ctx = null;
    const state = { lastTarget: null };
    let streak = 0; // aantal achtereenvolgende goede antwoorden

    function setTip(t) { tipEl.textContent = t || '\u00A0'; }
    function chooseTarget() { if (state.lastTarget === 'breed') return 'smal'; if (state.lastTarget === 'smal') return 'breed'; return Math.random() < .5 ? 'breed' : 'smal'; }
    function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }

    // Kleurhelpers
    function hsl(h, s, l) { return `hsl(${h} ${s}% ${l}%)`; }
    function gradientFromHue(h) { return `linear-gradient(180deg, ${hsl(h,85,70)}, ${hsl(h,85,55)})`; }
    function randomColorPair() { const h1 = randInt(0, 359); const offset = randInt(40, 160); const h2 = (h1 + offset) % 360; return [gradientFromHue(h1), gradientFromHue(h2)]; }

    // Inactiviteit met herhaalzin
    let idleTimer = null; const IDLE_TIMEOUT = 20000;
    function scheduleIdle() {
      if (idleTimer) clearTimeout(idleTimer);
      idleTimer = setTimeout(() => {
        if (!compared) { const msg = 'Vergelijk de vormen, sleep de rechthoeken boven elkaar'; setTip(msg); speak(msg); }
        else { const tgt = playzone.dataset.target || state.lastTarget || 'breed'; const msg = `Sleep de rechthoek die ${tgt} is naar de cirkel`; setTip(msg); speak(msg); }
        scheduleIdle();
      }, IDLE_TIMEOUT);
    }

    // Oog animatie helpers
    function setPupils(shape, x = 50, y = 58) { shape.querySelectorAll('.eye .pupil').forEach(p => { p.style.left = x + '%'; p.style.top = y + '%'; }); }
    function triggerBlink(shape) { shape.querySelectorAll('.eye').forEach(e => { e.classList.add('blink'); setTimeout(() => e.classList.remove('blink'), 160); }); }
    function scanBurst(shape) { const steps = randInt(1,2); let i = 0; const hop = () => { setPupils(shape, randInt(44,56), randInt(56,60)); if (++i < steps) setTimeout(hop, randInt(220,400)); }; hop(); }
    function startScan(shape) { if (shape._idleTimer) clearTimeout(shape._idleTimer); const loop = () => { shape._idleTimer = setTimeout(() => { if (!document.body.contains(shape)) return; if (shape.classList.contains('dragging')) { loop(); return; } if (Math.random() < 0.5) triggerBlink(shape); else scanBurst(shape); loop(); }, randInt(1500,4500)); }; loop(); }
    function stopScan(shape) { if (shape._idleTimer) { clearTimeout(shape._idleTimer); shape._idleTimer = null; } }
    function glanceAt(shape, other) { stopScan(shape); const c1 = centerOf(shape), c2 = centerOf(other); const px = c2.x > c1.x ? 56 : 44; const py = randInt(56,60); setPupils(shape, px, py); }
    function wink(shape) { triggerBlink(shape); setTimeout(() => triggerBlink(shape), 160); }

    // Spraak met on-end callback
    function speak(text, onend = null, options = {}) {
      if (!audioOn) return;
      const interrupt = options.interrupt !== false; // default: interrupt previous
      const u = new SpeechSynthesisUtterance(text);
      u.rate = 1.0; u.pitch = 1.0;
      if (voiceChoice) u.voice = voiceChoice;
      if (typeof onend === 'function') u.addEventListener('end', onend, { once: true });
      if (interrupt) window.speechSynthesis.cancel();
      window.speechSynthesis.speak(u);
      return u;
    }
    function pickDutchVoice() { const vs = speechSynthesis.getVoices(); voiceChoice = vs.find(v => v.lang && v.lang.toLowerCase().startsWith('nl')) || null; }

    // Geluidjes
    function playSuccess() { if (!audioOn || !ctx) return; let t = ctx.currentTime; [784, 988, 1319].forEach((f, i) => { const o = ctx.createOscillator(); const g = ctx.createGain(); o.type = 'sine'; o.frequency.setValueAtTime(f, t + i*0.12); g.gain.setValueAtTime(0.0001, t + i*0.12); g.gain.exponentialRampToValueAtTime(0.2, t + i*0.12 + 0.02); g.gain.exponentialRampToValueAtTime(0.0001, t + i*0.12 + 0.2); o.connect(g); g.connect(ctx.destination); o.start(t + i*0.12); o.stop(t + i*0.12 + 0.22); }); }
    function playError() { if (!audioOn || !ctx) return; let t = ctx.currentTime; const o = ctx.createOscillator(); const g = ctx.createGain(); o.type = 'sawtooth'; o.frequency.setValueAtTime(300, t); g.gain.setValueAtTime(0.2, t); o.frequency	exponentialRampToValueAtTime(140, t + 0.25); g.gain.exponentialRampToValueAtTime(0.0001, t + 0.26); o.connect(g); o.start(t); o.stop(t + 0.28); }

    // Confetti effect
    function confettiBurst(duration = 1600) {
      celebration.innerHTML = '';
      const colors = ['#6c7cff', '#8ec5ff', '#ffb86c', '#ffd49b', '#5ec27a', '#ffe27a'];
      for (let i = 0; i < 80; i++) {
        const s = document.createElement('span');
        s.className = 'confetti';
        s.style.left = randInt(0, app.clientWidth) + 'px';
        s.style.top = '-20px';
        s.style.background = colors[randInt(0, colors.length - 1)];
        s.style.transform = `translateY(-30px) rotate(${randInt(0,360)}deg)`;
        s.style.animationDuration = duration / 1000 + 's';
        s.style.animationDelay = (Math.random() * .2) + 's';
        s.style.width = randInt(6, 12) + 'px';
        s.style.height = randInt(10, 18) + 'px';
        celebration.appendChild(s);
      }
      setTimeout(() => { celebration.innerHTML = ''; }, duration + 100);
      return duration;
    }

    function renderStreak() {
      if (!streakEl) return;
      streakEl.innerHTML = '';
      const maxDots = 10; // visuele limiet, cosmetisch
      const count = Math.min(streak, maxDots);
      for (let i = 0; i < count; i++) {
        const d = document.createElement('span');
        d.className = 'sDot on';
        streakEl.appendChild(d);
      }
    }

    // Hulpfuncties
    function centerOf(el) { const r = el.getBoundingClientRect(); return { x: r.left + r.width / 2, y: r.top + r.height / 2 }; }
    function overlapRatio(a, b) { const ra = a.getBoundingClientRect(); const rb = b.getBoundingClientRect(); const x = Math.max(0, Math.min(ra.right, rb.right) - Math.max(ra.left, rb.left)); const y = Math.max(0, Math.min(ra.bottom, rb.bottom) - Math.max(ra.top, rb.top)); const area = x * y; const minA = Math.min(ra.width * ra.height, rb.width * rb.height); return minA ? area / minA : 0; }
    function insideDrop(el) { const c = centerOf(el); const r = dropCircle.getBoundingClientRect(); const dx = c.x - (r.left + r.width / 2); const dy = c.y - (r.top + r.height / 2); const dist = Math.sqrt(dx*dx + dy*dy); return dist < r.width / 2; }

    // Shapes
    function makeShape(kind, width, height, background) {
      const s = document.createElement('div');
      s.className = 'shape'; s.dataset.kind = kind; s.style.width = width + 'px'; s.style.height = height + 'px'; s.style.background = background;
      s.innerHTML = `
      <div class="eyes">
        <div class="eye"><div class="pupil"></div><div class="lid-top"></div><div class="lid-bottom"></div></div>
        <div class="eye"><div class="pupil"></div><div class="lid-top"></div><div class="lid-bottom"></div></div>
      </div>
      <div class="eyes-closed"><div class="lid"></div><div class="lid"></div></div>`;
      playzone.appendChild(s);
      try { const rim = getComputedStyle(s).borderColor; s.style.setProperty('--rim', rim); } catch {}
      return s;
    }

    function placeShapes(s1, s2) {
      const p = playzone.getBoundingClientRect();
      const pad = 24;
      s1.style.left = pad + 'px';
      s1.style.top = ((p.height - s1.offsetHeight) / 2) + 'px';
      s2.style.left = (p.width/2 + pad) + 'px';
      s2.style.top = ((p.height - s2.offsetHeight) / 2) + 'px';
    }

    function setInstruction() {
      const msg = 'Vergelijk de vormen, sleep de rechthoeken boven elkaar';
      setTip(msg);
      speak(msg);
    }

    function clearShapes() {
      playzone.querySelectorAll('.shape').forEach(el => {
        if (el._idleTimer) { clearTimeout(el._idleTimer); el._idleTimer = null; }
        el.remove();
      });
    }

    function nextRound() {
      setTip(''); compared = false; dropCircle.classList.remove('glow', 'shake'); clearShapes();
      const target = chooseTarget(); state.lastTarget = target; setInstruction();
      const base = randInt(140, 220); const delta = randInt(12, 30);
      const widths = Math.random() < .5 ? [base, base + delta] : [base + delta, base];
      const colors = randomColorPair(); const heights = [randInt(90,160), randInt(90,160)];
      const A = makeShape('A', widths[0], heights[0], colors[0]);
      const B = makeShape('B', widths[1], heights[1], colors[1]);
      placeShapes(A, B);
      [A, B].forEach(s => enableDrag(s));
      [A, B].forEach(startScan);
      scheduleIdle();
      playzone.dataset.target = target; playzone.dataset.widthA = widths[0]; playzone.dataset.widthB = widths[1];
    }

    function enableDrag(el) {
      let startX = 0, startY = 0, origLeft = 0, origTop = 0; let dragging = false;
      el.addEventListener('pointerdown', (e) => {
        el.setPointerCapture(e.pointerId);
        dragging = true; el.classList.add('dragging'); stopScan(el);
        startX = e.clientX; startY = e.clientY;
        const st = getComputedStyle(el); origLeft = parseFloat(st.left); origTop = parseFloat(st.top);
        scheduleIdle();
      });
      el.addEventListener('pointermove', (e) => {
        if (!dragging) return;
        const dx = e.clientX - startX; const dy = e.clientY - startY;
        el.style.left = (origLeft + dx) + 'px'; el.style.top = (origTop + dy) + 'px';
        scheduleIdle();
        const other = [...playzone.querySelectorAll('.shape')].find(n => n !== el);
        if (other) {
          glanceAt(other, el);
          const otherLeft = parseFloat(getComputedStyle(other).left);
          const thisLeft = parseFloat(getComputedStyle(el).left);
          const nearLeft = Math.abs(thisLeft - otherLeft) < 12; if (nearLeft) el.style.left = otherLeft + 'px';
          const r = overlapRatio(el, other);
          const c1 = centerOf(el), c2 = centerOf(other); const dyc = Math.abs(c1.y - c2.y);
          const stacked = nearLeft && dyc > 80 && dyc < 200;
          if (r > 0.55 || stacked) {
            if (!compared) {
              compared = true; dropCircle.classList.add('glow');
              const tgt = playzone.dataset.target || 'breed';
              setTip(`Sleep de rechthoek die ${tgt} is naar de cirkel`);
              // Eerst volledig uitspreken, daarna vervolgzin
              speak('Goed, je vergelijkt de vormen', () => {
                speak(`Sleep de rechthoek die ${tgt} is naar de cirkel`, null, { interrupt: true });
              }, { interrupt: true });
            }
            el.classList.add('good'); setTimeout(() => el.classList.remove('good'), 400);
          }
        }
      });
      const end = () => {
        if (!dragging) return; dragging = false; el.classList.remove('dragging'); scheduleIdle();
        const other = [...playzone.querySelectorAll('.shape')].find(n => n !== el);
        startScan(el); if (other) startScan(other);
        if (insideDrop(el)) {
          if (!compared) {
            setTip('Vergelijk eerst, schuif de rechthoeken boven elkaar');
            speak('Vergelijk eerst, schuif de rechthoeken boven elkaar');
            dropCircle.classList.add('shake'); playError(); setTimeout(() => dropCircle.classList.remove('shake'), 400);
            return;
          }
          checkAnswer(el);
        }
      };
      el.addEventListener('pointerup', end); el.addEventListener('pointercancel', end);
    }

    function checkAnswer(el) {
      const target = playzone.dataset.target;
      const wA = parseInt(playzone.dataset.widthA, 10);
      const wB = parseInt(playzone.dataset.widthB, 10);
      const bigger = wA > wB ? 'A' : 'B';
      const smaller = wA > wB ? 'B' : 'A';
      const correctKind = target === 'breed' ? bigger : smaller;

      if (el.dataset.kind === correctKind) {
        streak += 1; renderStreak();
        setTip('Goed gedaan');
        speak('Goed zo');
        playSuccess();
        const confDur = confettiBurst(1600);
        wink(el);
        setTimeout(() => { nextRound(); }, confDur + 200);
      } else {
        streak = 0; renderStreak();
        const rule = target === 'breed' ? 'Als de vorm breed is, dan zijn de zijkanten ver uit elkaar' : 'Als de vorm smal is, dan zijn de zijkanten dicht bij elkaar';
        const msg = (target === 'breed' ? 'We zoeken breed, kijk nog eens' : 'We zoeken smal, kijk nog eens') + '. ' + rule;
        setTip(msg); speak(msg);
        dropCircle.classList.add('shake'); playError(); setTimeout(() => dropCircle.classList.remove('shake'), 400);
      }
    }

    function resetGame() { streak = 0; renderStreak(); nextRound(); }

    // Knoppen
    btnRepeat.addEventListener('click', () => { setInstruction(); });
    btnMute.addEventListener('click', () => { audioOn = !audioOn; btnMute.textContent = audioOn ? 'üîä Geluid' : 'üîà Stil'; });

    // Start robuust
    function startGame(withAudio = true) {
      if (withAudio) { try { ctx = new (window.AudioContext || window.webkitAudioContext)(); } catch {} }
      gate.classList.add('hidden'); setTimeout(() => { if (gate && gate.parentNode) gate.remove(); }, 60);
      resetGame();
    }
    btnStart.addEventListener('click', () => startGame(true));
    gate.addEventListener('click', (e) => { if (e.target === gate) startGame(true); });
    document.addEventListener('keydown', (e) => { if ((e.key === 'Enter' or e.key == ' ') && document.body.contains(gate)) startGame(true); });
    // Extra failsafe: als overlay blijft hangen, start visueel zonder audio
    setTimeout(() => { if (document.body.contains(gate)) startGame(false); }, 1500);

    // Voices laden
    window.speechSynthesis.onvoiceschanged = pickDutchVoice; pickDutchVoice();

    // Drop-circle pulse
    const pulse = () => { dropCircle.classList.toggle('glow'); setTimeout(() => dropCircle.classList.toggle('glow'), 1200); };
    setInterval(pulse, 3000);

    // Reposition bij resize
    window.addEventListener('resize', () => {
      const shapes = playzone.querySelectorAll('.shape');
      if (shapes.length === 2) { placeShapes(shapes[0], shapes[1]); }
    });

    // Zelftest
    (function runSelfTests(){
      try {
        console.assert(typeof speak === 'function', 'speak() ontbreekt');
        console.assert(typeof chooseTarget === 'function', 'chooseTarget() ontbreekt');
        const t = chooseTarget();
        console.assert(t === 'breed' || t === 'smal', 'chooseTarget ongeldig');
      } catch(e) { console.error('Zelftest faalde', e); }
    })();
  </script>
</body>
</html>
